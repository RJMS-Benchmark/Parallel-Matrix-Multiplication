/* 
 * File:   main.c
 * Author: Benno Waldhauer
 *
 * Created on 1. November 2010, 15:09
 */

/*

Things to do:
  
  - change Timemeasurement from clock_t clock() to double omp_get_wtime()
  - ad options for parallel computing omp, pthread, etc
  - create better logger
  - maybe different types vor initialise matrices A and B 


*/

#include <omp.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#include "header.h"

#include "lib.c"
#include "logger.c"
#include "seq.c"
#include "omp.c"
#include "pthread.c"

/*
 * main  A*B=C
 */

//char method[10];

int main(int argc, char *argv[]) {
  
  timestamp = time (NULL);  // gets the actuell time in s from 1.1.1970 as LogID in log file
  numOfProc=omp_get_num_procs();

  m=10; 
  n=10;
  p=10;
  print =0;
  method =0;

  printf("\nWelcome\n\n A[m][n] * B[n][p] = C[m][p]\n\n");	

  if(argc<4){ //if less then 3 arguments are providet, then ask vor the metrices dimensions
	  printf("Please define m n and p!\n");	
	  printf("\n m = "); // ask for user input
	  scanf("%d",&m); // scan user input
	  printf(" n = ");
	  scanf("%d",&n);
	  printf(" p = ");
	  scanf("%d",&p);
  }else{ // when min 3 arguments are providest, then use them
	  m=strtol(argv[1], NULL, 10); // argument string to long int 
	  printf(" m = %d\n",m);
	  n=strtol(argv[2], NULL, 10);
	  printf(" n = %d\n",n);
	  p=strtol(argv[3], NULL, 10);
	  printf(" p = %d\n",p);
  }
 
  if(argc<5){ // if there is no 4th argument, then ask vor the printer options
	  printf("\nChoose print option\n\n 0 = nothing\n 1 = print to screen\n \
2 = print to file\n 3 = print to screen and to file\n\n print = ");
	  scanf("%d",&print);
  }else{ // 4th arg = printer option
 	  print=strtol(argv[4], NULL, 10);
	  printf(" print = %d \n",print);
  }
  
  if(argc<6){
  	 // printf("\nChoose method for matrix computing\n\n 0 = sequential\n 1 = parallel with openMP\n \
  	 2 = compare sequential and openMP\n method = ");
	 
	 //  scanf("%d",&method);
  }
  else{
	//  method=strtol(argv[5], NULL, 10);
	//  printf(" method = %d",method); 
  }

  printf("\n\nStart malloc of matrices ... \n\n");	
 
  matrix A = {"A",m,n};
  matrix B = {"B",n,p};
  matrix C = {"SEQ",m,p};
  matrix D = {"OMP",m,p};
  //matrix E = {"OMP2",m,p};
  
    
  A.matrix=mallocMatrix(A);	// returns the allocated Matrix now  // matrixA[height value][hight value] is available
  B.matrix=mallocMatrix(B);
  C.matrix=mallocMatrix(C);
  D.matrix=mallocMatrix(D);
  //E.matrix=mallocMatrix(E);
  
  matrixInitRowPlusCol(A);
  matrixInitRowPlusCol(B); 

  multiReturn seq=matrixMultiSEQ(A,B,C);
  
  multiReturn omp=matrixMultiOMP(A,B,D);
  //multiReturn omp2=matrixMultiOMP2(A,B,E); 
  
  matrixCompare(C,D);
  //matrixCompare(C,E); 
  
  printMatrix(A,print); // prints the matrices depending on the print parameter... 
  printMatrix(B,print); // nothing, screen, file, both 

  printMatrix(D,print);
  //printMatrix(E,print);	
		
  logger(seq);
  logger(omp);
  //logger(omp2);	

  

 // matrix F = {"PTHREAD",m,p};
 // F.matrix=mallocMatrix(F);
 // multiReturn pth=matrixMultiPTH(A,B,F);
 // matrixCompare(C,F);
 // printMatrix(F,print);
 // logger(pth);

  freeMatrix(A); // deallocate the matrices
  freeMatrix(B);
  freeMatrix(C);
  freeMatrix(D);
  freeMatrix(E);
  
 // freeMatrix(F);

  printf("\n");

  return (EXIT_SUCCESS);
}
